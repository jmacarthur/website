<!DOCTYPE html>
    <html>
    <head>
    <link rel="stylesheet" href="styles.css"><title>Mechanical replica of the Manchester SSEM (Baby)</title></head><body><h1>Mechanical replica of the Manchester SSEM (Baby)</h1>
<p>I've not posted here in a while because I've been working on one big project, a mechanical version of Manchester University's <a href="https://en.wikipedia.org/wiki/Manchester_Baby">Small-Scale Experimental Machine</a>	, otherwise known as the Baby.</p>
<p>Previous machines I've built have been either Turing machines or other simple automata such as <a href="langtons-ant.html">Langton's Ant</a>. These are relatively simple machines compared to the current project, but would require vast amounts of space and time to do anything useful.</p>
<p>Implementing something that looks similar to a modern computer is entirely possible. The SSEM is a very simple machine, so makes a good design to base a mechanical computer on. Its main features are:</p>
<ul>
<li>RAM with 32 addressable words of 32 bits each, for a total of 1024 bits of storage.</li>
<li>Two special-purpose registers: the accumulator and program counter</li>
<li>A subtractor unit where most CPUs would have a more general arithmetic and logic unit.</li>
</ul>
<p>Here's a diagram from Wikipedia, of the SSEM datapath:</p>
<p><div class="imagebox"><div class="imagecontainer"><img class="inlineimg" src="inline_images/BabyArchitecture.png" alt="SSEM architecture diagram by Malles Fatuorum via Wikimedia Commons (CC-BY-3.0)"></div><center>SSEM architecture diagram by Malles Fatuorum via Wikimedia Commons (CC-BY-3.0)</center></div></p><p>The subtractor only feeds into the accumulator - so the accumulator can only be updated with the result of a subtraction. Not only that, but the first operand to the subtraction is always the accumulator or zero. You can also see this in the instruction set: MVN and SUB are the only operations which update the accumulator. MVN ('move negative') of X just means set the accumulator to 0-X, so you only need to clear the accumulator first before treating MVN exactly as a SUB.</p>
<p>In practical terms, that means we can combine the subtractor and accumulator into one unit. The design for the subtractor is a fairly common one, used by the Digi-Comp II in the 1960s. It consists of a staircase of toggles which change direction when a ball bearing passes through them, sending the bearing left or right depending on its new state. The diagonal arrangement allows for carry - a ball bearing continuing left will flip the next most significant bit.</p>
<p><div class="imagebox"><div class="imagecontainer"><img class="inlineimg" src="inline_images/subtractor.gif" alt="Subtractor/accumulator animation"></div><center>Subtractor/accumulator animation</center></div></p><p>What you can't see in this GIF is the second layer behind the main toggles, which divert a ball bearing without changing state - this is used to read the accumulator without updating it, by passing more ball bearings into a second plane.</p>
<p>Next up is the memory, which needs to be random-access. Below is an 8x8 cell made from lasercut acrylic:</p>
<p><div class="imagebox"><div class="imagecontainer"><img class="inlineimg" src="inline_images/vertical-memory-2.jpg" alt="Vertical 8x8 memory"></div><center>Vertical 8x8 memory</center></div></p><p>This really needs an animation to demonstrate how it works, which I'll try and make soon. This is an 8x8 cell, but it can be chained in both directions: connecting more units to the left would make the words longer, and adding units below increases the number of memory locations. In this way, this will eventually build up to the full 32x32 bit memory used by the SSEM.</p>
<p>The address decoder uses the <a href="decoder.html">Mechanical decoder logic</a> I mentioned in a previous post.</p>
<p>There are a lot more details still to add; the instruction counter also uses a staircase adder, and the instruction decoder will use the [[Mechanical array logic|array logic]] system from another older post. Devices which meter out exactly 8 ball bearings, sense ball bearings and transmit the data back to the top of the machine are all in progress. These turn out to be much more complicated than just the memory and arithmetic, but aren't so interesting from a computing point of view. All the details, along with some very badly documented OpenSCAD files, are up on GitHub, in my <a href="https://github.com/jmacarthur/offspring">Offspring</a> repository. ('Offspring' being a play on the original 'Baby' name, given the mechnical version will almost certainly require some springs.)</p>
<p><a href="index.html">Return to index</a></p></body>
</html>
